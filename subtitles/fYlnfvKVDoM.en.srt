1
00:03:54,990 --> 00:03:58,300
ladies and gentlemen just a quick
reminder before we get started this

2
00:03:58,300 --> 00:03:58,890
morning

3
00:03:58,890 --> 00:04:03,650
if you have a device that makes annoying
noises while the rest three silence

4
00:04:03,650 --> 00:04:07,560
probably save your favorite harassment
few made silent now

5
00:04:07,560 --> 00:04:14,560
side please do that but you can keep
documents

6
00:05:05,189 --> 00:05:12,189
not

7
00:05:27,320 --> 00:05:31,400
ready

8
00:05:31,400 --> 00:05:34,730
hello everyone welcome to the morning
session of the Friday of

9
00:05:34,730 --> 00:05:37,990
icon 2014 here in Montreal it's great to
see so many

10
00:05:37,990 --> 00:05:41,050
this word up so

11
00:05:41,050 --> 00:05:45,020
ralph is presented today is here 7 icon

12
00:05:45,020 --> 00:05:49,000
he's been using Python Saints 97 or 98

13
00:05:49,000 --> 00:05:53,250
he's not quite sure and tries to shake
everything he learns

14
00:05:53,250 --> 00:05:58,230
with the community that is given such a
great programming language chosen really

15
00:05:58,230 --> 00:05:58,610
good

16
00:05:58,610 --> 00:06:01,640
presentation presented to come to see
first-year

17
00:06:01,640 --> 00:06:08,640
icon please welcome Brandon Roberts

18
00:06:12,940 --> 00:06:16,760
well thank you welcome everybody to Pike
on up by I'm glad that y'all

19
00:06:16,760 --> 00:06:20,340
made it safely and I wish safe travels
to any haven't arrived yet

20
00:06:20,340 --> 00:06:24,130
I'm Grandin Road this is my talk

21
00:06:24,130 --> 00:06:29,770
all your docs in a row data structures
in the standard library and beyond

22
00:06:29,770 --> 00:06:34,170
I is sorta beginner to intermediate
level talk because very often

23
00:06:34,170 --> 00:06:38,530
people complain that they don't hearing
talk very much later about useful data

24
00:06:38,530 --> 00:06:39,280
structures

25
00:06:39,280 --> 00:06:42,950
hiding in a standard library there's a
lot of them that I didn't know about

26
00:06:42,950 --> 00:06:46,390
and so this tries to get them all into
one flight deck

27
00:06:46,390 --> 00:06:49,430
and all into one place what are the
purpose

28
00:06:49,430 --> 00:06:53,320
the stock you know in case you're
thinking walking next door to one of the

29
00:06:53,320 --> 00:06:54,120
other extreme

30
00:06:54,120 --> 00:06:58,910
talks its good for me to put this at the
beginning three main points

31
00:06:58,910 --> 00:07:02,690
how to data structures work how are they
actually implemented in memory and why

32
00:07:02,690 --> 00:07:04,760
does that make some operations efficient

33
00:07:04,760 --> 00:07:09,240
and some slow what can they do
efficiently for us

34
00:07:09,240 --> 00:07:12,450
and then finally I will reveal which

35
00:07:12,450 --> 00:07:16,060
data structure is High Times most

36
00:07:16,060 --> 00:07:20,660
dangerous in fact I will reveal it right
now in case you really want to be

37
00:07:20,660 --> 00:07:22,680
listening to one of the other excellent
speakers

38
00:07:22,680 --> 00:07:27,720
does the list to find out why don't have
to wait a few minutes

39
00:07:27,720 --> 00:07:31,170
computer memory

40
00:07:31,170 --> 00:07:34,950
is an array of byte little integers that
can have

41
00:07:34,950 --> 00:07:37,950
eat binary digits and all the value from

42
00:07:37,950 --> 00:07:41,760
0 to 255 by in memory

43
00:07:41,760 --> 00:07:45,820
are named by sequential integers called
addresses in your processor in your

44
00:07:45,820 --> 00:07:47,440
laptop or tablet

45
00:07:47,440 --> 00:07:51,470
asks for by number five in gets it back
for memory

46
00:07:51,470 --> 00:07:54,940
to save space all be writing by seen
rosa

47
00:07:54,940 --> 00:07:59,850
8 but there's simply a continuous
sequence with no break

48
00:07:59,850 --> 00:08:03,320
in the computer's hardware avram chips

49
00:08:03,320 --> 00:08:07,150
are one massively parallel computing
device in your computer

50
00:08:07,150 --> 00:08:10,820
which is what provide the random access
to a billion different locations without

51
00:08:10,820 --> 00:08:12,510
having to wait for a billion

52
00:08:12,510 --> 00:08:15,640
locations to be visited it has agreed

53
00:08:15,640 --> 00:08:18,960
are I am outlines the uses

54
00:08:18,960 --> 00:08:21,970
when you throw in address at your memory
chip

55
00:08:21,970 --> 00:08:25,850
it makes like billion simultaneous
decisions

56
00:08:25,850 --> 00:08:29,390
so that all $999 million

57
00:08:29,390 --> 00:08:33,620
I locations that aren't being asked for
their data at the moment kinda put their

58
00:08:33,620 --> 00:08:34,540
heads down

59
00:08:34,540 --> 00:08:39,930
and don't wanna location with address
line for just all that up green

60
00:08:39,930 --> 00:08:44,630
put its value on the outgoing data bus
in massively massively parallel

61
00:08:44,630 --> 00:08:45,840
computation

62
00:08:45,840 --> 00:08:49,240
does a do again I'll give you a billion
answers at once

63
00:08:49,240 --> 00:08:53,390
that's how you can get relocations I
with equal speed

64
00:08:53,390 --> 00:08:57,430
this talk will ignore a lot of the
complexity that now exist

65
00:08:57,430 --> 00:09:01,470
between the chip your processor and RAM

66
00:09:01,470 --> 00:09:06,330
both the question of compression the up
bus tour and is now so slow compared to

67
00:09:06,330 --> 00:09:07,280
your processor

68
00:09:07,280 --> 00:09:10,380
many researchers are compressing their
arrays

69
00:09:10,380 --> 00:09:15,720
in memory a because the processor has
Aegis to decompress a block that gets

70
00:09:15,720 --> 00:09:19,980
once it finally comes in from RAM am
going to ignore memory hierarchy but I

71
00:09:19,980 --> 00:09:21,580
strongly recommend you seek

72
00:09:21,580 --> 00:09:25,030
stoppard marks what your computer does
while you wait

73
00:09:25,030 --> 00:09:29,200
blog post and damn lose blog post very
recently

74
00:09:29,200 --> 00:09:33,370
how miss aligning your data can increase
performance 12 times

75
00:09:33,370 --> 00:09:38,070
along with the sample script for you can
see that work wide why ignore those

76
00:09:38,070 --> 00:09:39,220
issues in

77
00:09:39,220 --> 00:09:43,400
supposed to be a fairly technical talk
because the standard library

78
00:09:43,400 --> 00:09:48,790
does lists and dictionaries don't pay
attention to memory hierarchy very much

79
00:09:48,790 --> 00:09:49,370
at all

80
00:09:49,370 --> 00:09:55,050
and so I will follow suit RAF talking
about addresses these numbers that were

81
00:09:55,050 --> 00:09:55,520
used

82
00:09:55,520 --> 00:09:59,700
indexing relocations since they are
integers you can add and subtract from

83
00:09:59,700 --> 00:10:02,760
one address to visit another address
that sits near it

84
00:10:02,760 --> 00:10:07,360
address arithmetic then is used to
support the two fundamental

85
00:10:07,360 --> 00:10:10,670
data structures at the machine level
which I will call records

86
00:10:10,670 --> 00:10:14,320
and to raise a record is just when you
put them feel

87
00:10:14,320 --> 00:10:17,440
some information in an agreed order in
memory

88
00:10:17,440 --> 00:10:20,450
every pipe object in you your

89
00:10:20,450 --> 00:10:23,480
see pipe I memory store always start

90
00:10:23,480 --> 00:10:28,050
its record with eight bytes reference
count on a 64-bit machine

91
00:10:28,050 --> 00:10:32,839
and eat by address of the type you know
the integer type that has all the

92
00:10:32,839 --> 00:10:34,770
integer methods are the floating-point

93
00:10:34,770 --> 00:10:37,810
type that has all the floating-point
methods so this

94
00:10:37,810 --> 00:10:41,600
years I checked this is how I'm and is
actually laid out on my

95
00:10:41,600 --> 00:10:44,820
64-bit machine at home 24 by

96
00:10:44,820 --> 00:10:48,210
which only aid actually contain the
integer load

97
00:10:48,210 --> 00:10:51,480
are laid out similarly but use a
different formats they can

98
00:10:51,480 --> 00:10:54,870
story floating point number in their
payload in some

99
00:10:54,870 --> 00:10:58,440
height on data structures are variable

100
00:10:58,440 --> 00:11:01,930
here is one way of storing string it has

101
00:11:01,930 --> 00:11:05,080
fix different the by fields before

102
00:11:05,080 --> 00:11:08,700
then actually includes the payload the
actual string

103
00:11:08,700 --> 00:11:11,700
that I want to store given

104
00:11:11,700 --> 00:11:15,070
a record you retrieve the field by
adding

105
00:11:15,070 --> 00:11:19,060
the record started raff with the of
offset again

106
00:11:19,060 --> 00:11:22,770
very simple arithmetic involving these I
addresses

107
00:11:22,770 --> 00:11:25,900
so if I wanted to get the address at the
centers type

108
00:11:25,900 --> 00:11:29,400
I get the beginning at the record
address in at eight

109
00:11:29,400 --> 00:11:33,200
by wanton grab the integer payload I at
sixteen

110
00:11:33,200 --> 00:11:36,360
and if you know the layout of the record
a simple addition

111
00:11:36,360 --> 00:11:40,339
will let you get any element in it
instantly

112
00:11:40,339 --> 00:11:43,339
this is used to create a data structure

113
00:11:43,339 --> 00:11:47,160
at the sea level that is also exposed by
pipeline

114
00:11:47,160 --> 00:11:50,790
call struct in this is the name the
module you can import

115
00:11:50,790 --> 00:11:54,190
it lets you use a little formatting
straining

116
00:11:54,190 --> 00:11:57,480
II at in this case for integer integer
float

117
00:11:57,480 --> 00:12:01,040
to describe the structure the you want
to build and

118
00:12:01,040 --> 00:12:05,339
actually build exactly that fee
structure in memory

119
00:12:05,339 --> 00:12:10,130
and less you get those three objects 29
in 20 in this case

120
00:12:10,130 --> 00:12:13,310
rebuilt later abstract can be very
useful

121
00:12:13,310 --> 00:12:16,410
for having a binary conversation with
the C library

122
00:12:16,410 --> 00:12:20,260
were doing I O work packets require a
certain way out

123
00:12:20,260 --> 00:12:25,080
on but it's typically only for very low
level operations

124
00:12:25,080 --> 00:12:29,530
are the other one level om data
structure the Python exposes

125
00:12:29,530 --> 00:12:34,490
is the rainy how did the work

126
00:12:34,490 --> 00:12:38,790
in an array unlike a record everything
in it is same

127
00:12:38,790 --> 00:12:41,800
everything in it is the same link and
sell

128
00:12:41,800 --> 00:12:45,490
in a simple string if we want to get
character I

129
00:12:45,490 --> 00:12:48,660
we get the address for the first
character and had iight

130
00:12:48,660 --> 00:12:52,280
the address if instead it's a unique
code string

131
00:12:52,280 --> 00:12:55,500
and is using four bytes per each
character then

132
00:12:55,500 --> 00:12:58,580
the additional characters played a plus
for

133
00:12:58,580 --> 00:13:03,000
8 12 16 and 20 and in general with an
array I didn't is

134
00:13:03,000 --> 00:13:06,730
be bytes long you can instantly get any
item I

135
00:13:06,730 --> 00:13:10,750
simply by not applying be times I its
random access

136
00:13:10,750 --> 00:13:14,500
instant access just like your computer's
memory and so

137
00:13:14,500 --> 00:13:18,030
these r us for a complimentary
approaches you know record

138
00:13:18,030 --> 00:13:21,540
you add the of saps that you've
memorized

139
00:13:21,540 --> 00:13:25,740
to your field to get heterogeneous data
where everything means something

140
00:13:25,740 --> 00:13:26,480
different

141
00:13:26,480 --> 00:13:30,630
in an array use multiplication to get to
homogeneous information each element is

142
00:13:30,630 --> 00:13:31,890
the same way

143
00:13:31,890 --> 00:13:36,890
both by writing on top of that memory
chips massively parallel architecture

144
00:13:36,890 --> 00:13:40,000
gives you immediate access to the data
what

145
00:13:40,000 --> 00:13:43,110
their is an array module inside a python

146
00:13:43,110 --> 00:13:46,790
that gives you a tight similarly named
the array

147
00:13:46,790 --> 00:13:51,830
and not get if you get them I
information will pack it into memory

148
00:13:51,830 --> 00:13:55,200
as long as they're all same type I you
can

149
00:13:55,200 --> 00:13:58,250
mile-high the elements in and pull them
back out later

150
00:13:58,250 --> 00:14:01,339
very useful again for binary
conversations

151
00:14:01,339 --> 00:14:05,480
libraries are I L it taxed at a very
tightly

152
00:14:05,480 --> 00:14:09,370
and so python has a lot of specialized a
raise in addition to you

153
00:14:09,370 --> 00:14:14,330
a plane open our res streams unit code
and number of other data structures

154
00:14:14,330 --> 00:14:17,690
probably use every day are implemented
the machine level

155
00:14:17,690 --> 00:14:21,250
as a simple arrangements white indexing
is fast

156
00:14:21,250 --> 00:14:25,580
but accessing be items up an array

157
00:14:25,580 --> 00:14:29,839
requires repeated building objects to
represent the values

158
00:14:29,839 --> 00:14:33,370
if I'm going to iterate over an array of
floats you can see down there at the

159
00:14:33,370 --> 00:14:34,070
bottom

160
00:14:34,070 --> 00:14:37,770
icons gonna have to build a fresh load
object to let me

161
00:14:37,770 --> 00:14:42,400
see each other's values to summary of
100 floats in Python

162
00:14:42,400 --> 00:14:45,800
icons gonna have to build more than a
hundred load objects that were then

163
00:14:45,800 --> 00:14:46,690
thrown away

164
00:14:46,690 --> 00:14:51,090
all I want is some this is my the
invention have an incredibly powerful

165
00:14:51,090 --> 00:14:52,570
library called

166
00:14:52,570 --> 00:14:57,190
numb hi which is now the basis up nearly
all scientific and data

167
00:14:57,190 --> 00:15:00,270
Python computing height andre is

168
00:15:00,270 --> 00:15:04,990
they're very simple for see you right
now number higher res what you use when

169
00:15:04,990 --> 00:15:06,530
you're doing

170
00:15:06,530 --> 00:15:09,670
not higher res or map operations

171
00:15:09,670 --> 00:15:14,200
directly between a raise from scammers
without needing to build intermediate

172
00:15:14,200 --> 00:15:15,230
pipe on number

173
00:15:15,230 --> 00:15:18,380
objects so if I make a ranger 5 numbers

174
00:15:18,380 --> 00:15:21,960
and ask for the psalm Python only had to
allocate

175
00:15:21,960 --> 00:15:26,960
single aunt to give me the answer of the
computation occur internally

176
00:15:26,960 --> 00:15:30,050
and he writes been up two additional
arrays

177
00:15:30,050 --> 00:15:34,030
one bill multiplication and one with
addition night there up those

178
00:15:34,030 --> 00:15:38,010
even created a single pipe on number
object they happened directly

179
00:15:38,010 --> 00:15:41,670
apt sea level use numb hi were similar

180
00:15:41,670 --> 00:15:44,690
I library more the data orientation

181
00:15:44,690 --> 00:15:48,130
of called Anders if you need to do math

182
00:15:48,130 --> 00:15:52,710
on millions numbers with out meeting
millions a pipe object

183
00:15:52,710 --> 00:15:55,750
there's also a replacement umpire it's
on its way

184
00:15:55,750 --> 00:15:59,070
might also want to look at call plays

185
00:15:59,070 --> 00:16:02,210
note that if you use pipe high as your
interpreter

186
00:16:02,210 --> 00:16:06,150
it can auto-detect if you have built on
list with only cancer

187
00:16:06,150 --> 00:16:09,870
look Senate and might if it wants

188
00:16:09,870 --> 00:16:12,980
substitute a faster rate for it

189
00:16:12,980 --> 00:16:16,380
up icon itself now

190
00:16:16,380 --> 00:16:21,140
now work and sir have it here

191
00:16:21,140 --> 00:16:25,420
it can't use rar records a raise for
mister your data structures

192
00:16:25,420 --> 00:16:29,970
because it's a dynamic language where
everything is an object and we're not

193
00:16:29,970 --> 00:16:32,940
required to build lists where everything

194
00:16:32,940 --> 00:16:36,090
is the same supply palms mean data
structures

195
00:16:36,090 --> 00:16:39,580
are gonna general-purpose the need to be
capable

196
00:16:39,580 --> 00:16:44,610
holding any object I the two people for
example which will start with

197
00:16:44,610 --> 00:16:50,430
I can throw in float strings into it
without hearing how big they are

198
00:16:50,430 --> 00:16:53,430
how are those three objects going to yet
when they're

199
00:16:53,430 --> 00:16:56,890
up different sizes how am I going to
find them in memory of their

200
00:16:56,890 --> 00:17:00,330
each different way array address now

201
00:17:00,330 --> 00:17:04,330
that we looked at a few minutes ago
which is very fast depends on

202
00:17:04,330 --> 00:17:09,150
every elements be same number of bytes
long how's this going to work

203
00:17:09,150 --> 00:17:14,270
we all remember David wheeler one said
all problems in computer science can be

204
00:17:14,270 --> 00:17:15,209
solved

205
00:17:15,209 --> 00:17:20,480
by another Obama indirection so Eagle
added

206
00:17:20,480 --> 00:17:25,580
a triple does not store your objects in
line in the data structure

207
00:17:25,580 --> 00:17:29,280
it has an array out headdresses instead

208
00:17:29,280 --> 00:17:32,580
tell a critical book in memory for each
of the objects

209
00:17:32,580 --> 00:17:36,850
that you've stored this is indirection
when you store an address rather than a

210
00:17:36,850 --> 00:17:38,000
thing itself

211
00:17:38,000 --> 00:17:41,100
you can say to your friends IQ's hike on

212
00:17:41,100 --> 00:17:44,240
the language that gives you data
structures

213
00:17:44,240 --> 00:17:49,480
without any of the actual take all of
pythons general purpose data structures

214
00:17:49,480 --> 00:17:50,400
will see

215
00:17:50,400 --> 00:17:54,970
shaft store addresses and beef the
objects of somewhere else

216
00:17:54,970 --> 00:17:58,630
this means that moving an item in one of
these data structures

217
00:17:58,630 --> 00:18:01,810
only means copying an address your
actual

218
00:18:01,810 --> 00:18:05,610
floats are strings never have to get
moved around which is sufficient

219
00:18:05,610 --> 00:18:09,679
it means that there's only one copy of
an object regardless of how many times

220
00:18:09,679 --> 00:18:11,500
it appears in a tubal

221
00:18:11,500 --> 00:18:15,460
yesterday if you keep ur using that
string it's just the address that's

222
00:18:15,460 --> 00:18:16,260
getting copy

223
00:18:16,260 --> 00:18:19,840
each new data structure some given the
way out

224
00:18:19,840 --> 00:18:23,540
the tubal we saw grabbing it linked or
grabbing an item

225
00:18:23,540 --> 00:18:26,970
is just a single patch and so

226
00:18:26,970 --> 00:18:30,240
arm and there is by the way in the
collections module

227
00:18:30,240 --> 00:18:34,190
be named to people you want something
with the efficient storage a tubal

228
00:18:34,190 --> 00:18:37,310
but that gives you something more
convenient than integer indexes for

229
00:18:37,310 --> 00:18:38,940
accessing it items

230
00:18:38,940 --> 00:18:42,780
two balls are read-only a sequence
objects

231
00:18:42,780 --> 00:18:45,780
zero-based simplest pipelines

232
00:18:45,780 --> 00:18:48,780
general purpose data structures and

233
00:18:48,780 --> 00:18:52,190
now it because a triple knows its link

234
00:18:52,190 --> 00:18:57,240
it can do pounds checking

235
00:18:57,240 --> 00:19:04,240
might be important to you someday

236
00:19:06,150 --> 00:19:10,370
the next data structure up is called the
list lesser like triples but they're

237
00:19:10,370 --> 00:19:11,240
interesting

238
00:19:11,240 --> 00:19:15,320
because they can grow and the problem is
that once you've allocated

239
00:19:15,320 --> 00:19:19,390
your esten probably put some other
objects subsequent to it in memory

240
00:19:19,390 --> 00:19:24,169
its India it has data already allocated
in both sides a bit

241
00:19:24,169 --> 00:19:27,460
in that radio your computer's memory and

242
00:19:27,460 --> 00:19:30,880
it would now need to move it needs to
grow by another element

243
00:19:30,880 --> 00:19:35,429
because there's no extra room well you
know there is this guy

244
00:19:35,429 --> 00:19:38,830
maybe because by the way to beating you
can't easily move the last

245
00:19:38,830 --> 00:19:42,429
is all of the other data structures and
names reference it

246
00:19:42,429 --> 00:19:48,190
are just hold its address so if you move
it they won't be able to find it anymore

247
00:19:48,190 --> 00:19:51,760
so there's this guy name David wheeler
and he once said

248
00:19:51,760 --> 00:19:55,260
that all problems in computer science
can be solved

249
00:19:55,260 --> 00:19:59,720
by another level of indirection so
that's what the list does

250
00:19:59,720 --> 00:20:03,220
all it whole is it from link the science

251
00:20:03,220 --> 00:20:07,510
its storage and be address a block where
it puts the

252
00:20:07,510 --> 00:20:10,950
real addresses that then point to your
list items

253
00:20:10,950 --> 00:20:14,330
so two levels of indirection can solve
the problems one

254
00:20:14,330 --> 00:20:18,110
level does not now white at that list

255
00:20:18,110 --> 00:20:21,480
bring it up on the screen here again
have an extra work for what

256
00:20:21,480 --> 00:20:26,280
a-listers is is a twink 3 white wires
Python wasted space by having a blank

257
00:20:26,280 --> 00:20:27,030
element

258
00:20:27,030 --> 00:20:30,590
the answer is that if a python list
reserved no extra room

259
00:20:30,590 --> 00:20:34,560
the every single hand you did choir
reallocation

260
00:20:34,560 --> 00:20:37,890
reallocation is expensive each I can
address

261
00:20:37,890 --> 00:20:42,130
have to be copied to its new home in
your reallocate to a new free area

262
00:20:42,130 --> 00:20:45,900
memory Surrey allocation every append
would add up

263
00:20:45,900 --> 00:20:49,600
if at the second element I have to copy
the first address

264
00:20:49,600 --> 00:20:53,810
if at the third element I had to copy
the first and seconds address

265
00:20:53,810 --> 00:20:56,940
the you concede a link the chaff West 10

266
00:20:56,940 --> 00:21:00,919
10 depends would cost $45 address copies

267
00:21:00,919 --> 00:21:03,929
a thousand element list would require
happened million

268
00:21:03,929 --> 00:21:07,909
operations and E know again element last

269
00:21:07,909 --> 00:21:11,490
would require half trillion copies

270
00:21:11,490 --> 00:21:15,669
at that address in memory this is my
standard by the way

271
00:21:15,669 --> 00:21:19,570
thousand and million pot experiment that
I do to check with a mild rhythms are

272
00:21:19,570 --> 00:21:20,720
going to slow down

273
00:21:20,720 --> 00:21:23,740
when their data gets pic I think what's
the cost doing

274
00:21:23,740 --> 00:21:27,780
this operation thousand times and a
million times

275
00:21:27,780 --> 00:21:31,429
if the answer growth zeros at twice the
rate

276
00:21:31,429 --> 00:21:34,620
up the question I lose

277
00:21:34,620 --> 00:21:39,610
because the trail again if he bad bad
number

278
00:21:39,610 --> 00:21:43,730
and in general as you watch what were
you how many operations would you do

279
00:21:43,730 --> 00:21:45,179
with a thousand and how many

280
00:21:45,179 --> 00:21:49,100
million objects your computer science
friends tell you that there are

281
00:21:49,100 --> 00:21:53,010
remains for what happens if additional
three zeros

282
00:21:53,010 --> 00:21:56,550
gets the time 3 0's 40 rose

283
00:21:56,550 --> 00:21:59,610
or the very horrible 6 extra zeros

284
00:21:59,610 --> 00:22:03,020
why is a trillion horrible a million
seconds

285
00:22:03,020 --> 00:22:07,480
as an analogy is twelve days icon from
set up to tear down

286
00:22:07,480 --> 00:22:10,580
out million seconds it billion

287
00:22:10,580 --> 00:22:14,520
seconds is 31 years there are people in
this room

288
00:22:14,520 --> 00:22:19,360
who have not yet left billion seconds

289
00:22:19,360 --> 00:22:22,820
a trillion seconds its 31,000

290
00:22:22,820 --> 00:22:26,429
680 eight years if a true if you

291
00:22:26,429 --> 00:22:29,700
at if it really can seconds ago

292
00:22:29,700 --> 00:22:33,110
you went to the Bering Strait

293
00:22:33,110 --> 00:22:36,220
where dress warmly

294
00:22:36,220 --> 00:22:39,960
you would be waiting 20 thousand years

295
00:22:39,960 --> 00:22:43,790
before the first band hunter-gatherers
would walk past you

296
00:22:43,790 --> 00:22:47,179
from Asia and become the first humans to
enter

297
00:22:47,179 --> 00:22:50,429
the new world that's how long a trillion

298
00:22:50,429 --> 00:22:55,350
years cell has the best get out of this
problem

299
00:22:55,350 --> 00:22:58,530
and append on a whole left doesn't just
at one fly

300
00:22:58,530 --> 00:23:02,360
it at several and the list goes through
a series up expanding

301
00:23:02,360 --> 00:23:07,510
sizes a designing a data structure in
this way is called amortization because

302
00:23:07,510 --> 00:23:08,960
it spreads the cost

303
00:23:08,960 --> 00:23:13,610
reallocation over a lot of time just
like a mortgage dust for a loan

304
00:23:13,610 --> 00:23:18,139
and so if you build a thousand a million
or billion element list

305
00:23:18,139 --> 00:23:21,540
you the number free allocations stays
under control

306
00:23:21,540 --> 00:23:24,659
and national notice the number address
copies %uh

307
00:23:24,659 --> 00:23:28,659
only grows by about the number it zeroes
you're adding to the site secure data

308
00:23:28,659 --> 00:23:29,290
set

309
00:23:29,290 --> 00:23:32,770
that's very good performance amortized
cost

310
00:23:32,770 --> 00:23:36,730
do tend to be bumpy when you add the 990
first item

311
00:23:36,730 --> 00:23:40,090
the West is gonna jump up to 1120 flocks
and

312
00:23:40,090 --> 00:23:43,510
particular tend to be a bit slow the
list gets copied

313
00:23:43,510 --> 00:23:48,510
new on your location but in return the
next 130 items get appended

314
00:23:48,510 --> 00:23:53,220
at no additional cost that's called
amortization

315
00:23:53,220 --> 00:23:58,369
the Python last than illustrates a trade
off to save time and not have to do a

316
00:23:58,369 --> 00:23:58,960
trillion

317
00:23:58,960 --> 00:24:03,159
things we have to waste space in almost
every one of our list

318
00:24:03,159 --> 00:24:07,470
fact that there'll be some unused slots
at the end this is the classics

319
00:24:07,470 --> 00:24:12,860
speed versus space trade-off all of
Computer Science imposes on us

320
00:24:12,860 --> 00:24:17,580
and requires us to think through hype on
left I did a little measuring on average

321
00:24:17,580 --> 00:24:19,940
use about 94 percent after slot

322
00:24:19,940 --> 00:24:24,310
their slots so they're consuming 6
percent more space

323
00:24:24,310 --> 00:24:27,530
in order to be very fairy fast

324
00:24:27,530 --> 00:24:31,230
will be calling your time in computer
science so why did I say

325
00:24:31,230 --> 00:24:34,800
West is pipe bombs must

326
00:24:34,800 --> 00:24:38,389
dangerous data structure it's because I
think

327
00:24:38,389 --> 00:24:42,700
in the new programmers mind they tend to
look at whether an operation they're

328
00:24:42,700 --> 00:24:43,129
doing

329
00:24:43,129 --> 00:24:47,990
involves one item were many here since
single item operations on a West

330
00:24:47,990 --> 00:24:52,700
here are some several item operations on
a list and it makes sense to us that if

331
00:24:52,700 --> 00:24:53,379
we have

332
00:24:53,379 --> 00:24:56,490
on eat character uplifting do something
to ollie

333
00:24:56,490 --> 00:24:59,750
characters at all take about eight times
as long as one character

334
00:24:59,750 --> 00:25:03,659
last problem

335
00:25:03,659 --> 00:25:07,790
some up single item operations have to
touch

336
00:25:07,790 --> 00:25:12,610
every single item in the list with how
the ninth program are being aware of

337
00:25:12,610 --> 00:25:13,379
this

338
00:25:13,379 --> 00:25:17,510
if you in to the list for example very
fast

339
00:25:17,510 --> 00:25:21,750
if instead you insert at the beginning

340
00:25:21,750 --> 00:25:25,179
you'll be waiting the Bering Strait

341
00:25:25,179 --> 00:25:28,810
420 thousand years

342
00:25:28,810 --> 00:25:31,869
reading for your algorithm to finish

343
00:25:31,869 --> 00:25:35,740
if you pop from the end of a lift very
quick because that's where it's built to

344
00:25:35,740 --> 00:25:36,429
ingest

345
00:25:36,429 --> 00:25:39,440
P pop from the beginning the address at
every

346
00:25:39,440 --> 00:25:44,450
other item has to be shifted over one
fly every time you do it

347
00:25:44,450 --> 00:25:49,290
are that's why I often see people trying
programming for the first time

348
00:25:49,290 --> 00:25:53,830
what is it the items in reverse order
like this and wonder why a simple

349
00:25:53,830 --> 00:25:57,700
a few thousand items you know take 18
minutes or something

350
00:25:57,700 --> 00:26:00,820
this is how we do it idiomatic Python
instead

351
00:26:00,820 --> 00:26:04,280
to avoid that penalty the left is played
on

352
00:26:04,280 --> 00:26:08,440
most dangerous data structure if your
friend comes to you and says I

353
00:26:08,440 --> 00:26:12,340
started burning hike by and on

354
00:26:12,340 --> 00:26:16,210
you know my program is just sitting
there waiting for the next ice age

355
00:26:16,210 --> 00:26:19,290
look and see if they're using a blast

356
00:26:19,290 --> 00:26:24,220
slicing desserts brief mention because
the slicing operation

357
00:26:24,220 --> 00:26:27,440
a tight can choose whether it wants to
copy the data

358
00:26:27,440 --> 00:26:30,899
were generated view normally in Python
with

359
00:26:30,899 --> 00:26:35,090
I we use life an entirely new list is
created

360
00:26:35,090 --> 00:26:39,060
but that's expensive and that annoys
both scientists with lots of data

361
00:26:39,060 --> 00:26:42,260
and data scientists answer no

362
00:26:42,260 --> 00:26:46,419
high and pamper fleiss's are simple
Venus copy no data

363
00:26:46,419 --> 00:26:50,030
there like a little be classed when you
ask for element 50

364
00:26:50,030 --> 00:26:53,919
really goes and grabs element 450 if the
original sequence

365
00:26:53,919 --> 00:26:58,500
therefore they're very fast and very
efficient

366
00:26:58,500 --> 00:27:02,100
all right now we come to protect which I
won't give a lot of detail on because

367
00:27:02,100 --> 00:27:03,490
%uh the talk I did earlier

368
00:27:03,490 --> 00:27:06,760
I'll just say that while just doesn't
give you any choice

369
00:27:06,760 --> 00:27:10,610
names they're going to be integers the
dictionary that's you

370
00:27:10,610 --> 00:27:15,909
shoes the keys you want to look up data
with behind each dictionary to implement

371
00:27:15,909 --> 00:27:16,220
this

372
00:27:16,220 --> 00:27:19,889
is an array because that's the one thing
the computer does efficiently

373
00:27:19,889 --> 00:27:23,230
in which keys are stored it integer
index

374
00:27:23,230 --> 00:27:26,550
that built from something called the
keys hash value

375
00:27:26,550 --> 00:27:30,169
so that translators translates worse
from something complicated

376
00:27:30,169 --> 00:27:33,800
key to something simple an integer so
each slot

377
00:27:33,800 --> 00:27:38,290
the dictionary has to keep both the key
to remember what it was

378
00:27:38,290 --> 00:27:42,440
and without you see my icon 2010 talk to
Mike

379
00:27:42,440 --> 00:27:46,000
dictionary for colorfully illustrated
into higher

380
00:27:46,000 --> 00:27:49,700
guy how the dictionary works at
amortized cost

381
00:27:49,700 --> 00:27:53,980
I will say here only that it grows
because I know I should be with with

382
00:27:53,980 --> 00:27:58,169
to worry about this it grows by doubling
or quadrupling its size

383
00:27:58,169 --> 00:28:02,010
so the resize costs are amortized as
they are with the list

384
00:28:02,010 --> 00:28:06,260
resizes it two-thirds full so there
won't be too many hash collisions

385
00:28:06,260 --> 00:28:10,240
and therefore it's only ever one-third
to two-thirds

386
00:28:10,240 --> 00:28:13,389
fall art the slots in your dictionary

387
00:28:13,389 --> 00:28:16,460
at least one-third of them are empty at
any given time

388
00:28:16,460 --> 00:28:20,570
this classic speed versus pace trade-off
if you want to get to a dictionary

389
00:28:20,570 --> 00:28:24,899
item instantly you've got to get
something up in space is what we give up

390
00:28:24,899 --> 00:28:26,610
in Python

391
00:28:26,610 --> 00:28:30,929
given a key addict hashes it usually
jump right to it slot

392
00:28:30,929 --> 00:28:36,710
of dictionary operations are asked and
therefore safer beginning programmers

393
00:28:36,710 --> 00:28:41,010
takes one you did time to get one
element in units of time to get all of

394
00:28:41,010 --> 00:28:41,470
them

395
00:28:41,470 --> 00:28:45,710
very obvious and simple and well-behaved
common tasks that we do

396
00:28:45,710 --> 00:28:49,149
are joining counting grouping whenever
we have an order dated

397
00:28:49,149 --> 00:28:52,730
we gonna get associate instantly
incorrectly

398
00:28:52,730 --> 00:28:56,280
and because this is such a common
pattern you'll find in the collections

399
00:28:56,280 --> 00:28:56,940
module

400
00:28:56,940 --> 00:29:00,570
a default decked so that you can just
for example append

401
00:29:00,570 --> 00:29:04,899
to wiki without even worrying about
whether you put almost there yet

402
00:29:04,899 --> 00:29:08,960
you can at the default pic to put your
left there just in time for you to

403
00:29:08,960 --> 00:29:13,270
him to the right when they're created
and a sweet group these

404
00:29:13,270 --> 00:29:17,020
animals by there mother mammal a reptile

405
00:29:17,020 --> 00:29:20,510
I their is because it's so comment

406
00:29:20,510 --> 00:29:24,129
do that with integers to count there's a
counter class that you can give it a

407
00:29:24,129 --> 00:29:24,600
phrase

408
00:29:24,600 --> 00:29:27,790
will tell you the most common letters
you can get a list it'll tell you the

409
00:29:27,790 --> 00:29:29,260
most common items

410
00:29:29,260 --> 00:29:32,860
remember you can build compound
dictionary

411
00:29:32,860 --> 00:29:36,600
he's with the two people if a simple
integer left is in its sophisticated

412
00:29:36,600 --> 00:29:38,440
enough key for you

413
00:29:38,440 --> 00:29:42,030
if T order at the items doesn't matter
same looking over a

414
00:29:42,030 --> 00:29:45,860
wat projects to see what languages tend
to be used together

415
00:29:45,860 --> 00:29:49,200
use a frozen set because those are not
sensitive to order

416
00:29:49,200 --> 00:29:52,500
or coursework turkeys before turning
them into two pools but

417
00:29:52,500 --> 00:29:56,300
I prefer sets because the deck to signs

418
00:29:56,300 --> 00:29:59,730
each key to an array index by a hash get

419
00:29:59,730 --> 00:30:03,210
always forgets its order eatery in
arbitrary order

420
00:30:03,210 --> 00:30:06,419
nasty see the list in Dec to kind of the
opposite to each other

421
00:30:06,419 --> 00:30:10,060
Booklist only does order task really
passed in well

422
00:30:10,060 --> 00:30:14,290
the dictionary only maintains the
association and throws out the order

423
00:30:14,290 --> 00:30:18,260
to data structures two superpowers what
if you want both

424
00:30:18,260 --> 00:30:21,750
then their isn't ordered decked in the
standard library

425
00:30:21,750 --> 00:30:25,790
you'll find it in the collections module
and you iterate later

426
00:30:25,790 --> 00:30:29,820
remembers the order that the keys were
added in if you need that

427
00:30:29,820 --> 00:30:34,409
at great for things like header fields
Jason data that you want print back

428
00:30:34,409 --> 00:30:37,889
out in the same order later that it came
in

429
00:30:37,889 --> 00:30:42,330
there is a set built into Python it's
just a dictionary with only keys but no

430
00:30:42,330 --> 00:30:43,159
values

431
00:30:43,159 --> 00:30:46,800
and get support all upbeat set
operations you might have learned in

432
00:30:46,800 --> 00:30:48,929
math class at very high speed

433
00:30:48,929 --> 00:30:52,139
very obvious very little danger

434
00:30:52,139 --> 00:30:55,889
classes I should mention are by default
implemented with the dictionary

435
00:30:55,889 --> 00:31:00,220
each attribute is a key in a hidden
dictionary but you can turn it into a

436
00:31:00,220 --> 00:31:00,869
record

437
00:31:00,869 --> 00:31:03,919
you can turn it in one of those really
efficient data structures I showed you

438
00:31:03,919 --> 00:31:04,929
at the beginning

439
00:31:04,929 --> 00:31:08,859
by pre specifying slot to let you pick
that up in the documentation

440
00:31:08,859 --> 00:31:12,129
if you want to know how to have millions
of objects that are stored a bit more

441
00:31:12,129 --> 00:31:14,300
efficiently

442
00:31:14,300 --> 00:31:17,560
well those are the main data structures
those

443
00:31:17,560 --> 00:31:21,030
are workhorses those are what we use
what's left

444
00:31:21,030 --> 00:31:25,490
a few other little topics all touch on
here

445
00:31:25,490 --> 00:31:29,810
first dictionaries Leicester great for
grabbing one thing

446
00:31:29,810 --> 00:31:33,730
or iterating over all the things but
what if you want to fetch

447
00:31:33,730 --> 00:31:36,770
Ranger things you can sort

448
00:31:36,770 --> 00:31:39,990
a list or array in use the bisect module

449
00:31:39,990 --> 00:31:44,080
you can say let's say I want all the
numbers between three and four

450
00:31:44,080 --> 00:31:47,179
and it doesn't really efficient binary
search

451
00:31:47,179 --> 00:31:51,450
at narrowing in very quickly on where
that range begins and ends

452
00:31:51,450 --> 00:31:54,879
so that you can pull it out of your
lester earl Ray

453
00:31:54,879 --> 00:31:58,700
sometimes we want to list that can be
modified both ends instead only the

454
00:31:58,700 --> 00:31:59,399
right

455
00:31:59,399 --> 00:32:02,409
there is he Dec built in the collections
module

456
00:32:02,409 --> 00:32:05,480
that instead of just supporting a
pending pop at the right

457
00:32:05,480 --> 00:32:08,490
and which by the way kids you what's
called stack

458
00:32:08,490 --> 00:32:11,830
which is a very natural way organized
tasks

459
00:32:11,830 --> 00:32:15,000
inside half you need to do Dec

460
00:32:15,000 --> 00:32:18,879
lets you modify both hands with an
append

461
00:32:18,879 --> 00:32:22,100
and in a pan left a pop and a pop

462
00:32:22,100 --> 00:32:25,869
laughed and since you can put items in
one hand

463
00:32:25,869 --> 00:32:30,080
and take them out the other very
efficiently is the data structures

464
00:32:30,080 --> 00:32:33,139
secretly behind the Q which is a Dec

465
00:32:33,139 --> 00:32:36,710
with ox on it so that your threads can
all cooperate

466
00:32:36,710 --> 00:32:40,480
send data or messages to each other

467
00:32:40,480 --> 00:32:44,500
we can you do a popularity contest your
lot from what elements and you trust

468
00:32:44,500 --> 00:32:48,940
deed the top ten are the top 100 with
out the expensive sorting the entire

469
00:32:48,940 --> 00:32:49,740
sequence

470
00:32:49,740 --> 00:32:52,909
their is a heap cue that lets you fetch
the top

471
00:32:52,909 --> 00:32:57,379
in Afghan t getting items in only when
your time

472
00:32:57,379 --> 00:33:01,520
on TNN om you just get some sequence

473
00:33:01,520 --> 00:33:07,310
you keep a fire it does a little like um
tournament elimination contest to it

474
00:33:07,310 --> 00:33:11,080
get them ranked into tears %uh more and
last sorted

475
00:33:11,080 --> 00:33:14,480
I information and then can pop and push

476
00:33:14,480 --> 00:33:17,560
very very quickly and the II

477
00:33:17,560 --> 00:33:21,869
model goes ahead and get you in and
largest and smallest callable

478
00:33:21,869 --> 00:33:25,310
that does all of those steps for you to
get that

479
00:33:25,310 --> 00:33:30,679
100 biggest objects without having to
sort all million items in your range

480
00:33:30,679 --> 00:33:34,330
there's a priority cue also I believe in
the queue module

481
00:33:34,330 --> 00:33:38,730
which is a heap cue with locks so that
threats can cooperate

482
00:33:38,730 --> 00:33:43,639
on might work highest work where the
work is labeled with priorities that

483
00:33:43,639 --> 00:33:47,340
make some items come of up that cue
earlier

484
00:33:47,340 --> 00:33:50,440
and others there's also a scheduler
module

485
00:33:50,440 --> 00:33:53,820
uses the cue you can get items on your
calendar

486
00:33:53,820 --> 00:33:57,270
or events on your server that need to
take place and it'll tell you how long

487
00:33:57,270 --> 00:33:58,750
to wait until the next one

488
00:33:58,750 --> 00:34:02,100
triggers using again this really
efficient PQ

489
00:34:02,100 --> 00:34:07,340
cell where all of the old fashioned data
structures

490
00:34:07,340 --> 00:34:11,169
all the ones you read about Donald can
use book 3

491
00:34:11,169 --> 00:34:15,790
linked with doubly linked list in all
the trees

492
00:34:15,790 --> 00:34:19,159
my suggestion is this you don't see them
Python code

493
00:34:19,159 --> 00:34:23,399
because they make very little sense when
our data structures

494
00:34:23,399 --> 00:34:26,590
no longer campaign data but only

495
00:34:26,590 --> 00:34:30,070
addresses you see back in the old days
you would go bombing

496
00:34:30,070 --> 00:34:33,169
left by actually putting the links in
with your dad

497
00:34:33,169 --> 00:34:37,770
which wasn't that big a deal what cost
one extra link when you have to speak

498
00:34:37,770 --> 00:34:42,240
record-setting there but in Python where
everything is an object relinquished

499
00:34:42,240 --> 00:34:46,290
only consists of another address
together with the links it's much more

500
00:34:46,290 --> 00:34:48,609
efficient to just have a list and put
the address is

501
00:34:48,609 --> 00:34:51,810
altogether both Dec Andy

502
00:34:51,810 --> 00:34:55,220
work decked do secretly have EE linked
with inside

503
00:34:55,220 --> 00:34:58,790
for their accounting but all the other
linked with you're really using in

504
00:34:58,790 --> 00:34:59,590
production

505
00:34:59,590 --> 00:35:02,740
are hidden in your memory allocation
player since you're I

506
00:35:02,740 --> 00:35:07,210
objects are already allocated by Malik
inside at the secret linked list

507
00:35:07,210 --> 00:35:10,530
it's just kind of redundant to try to do
memory management

508
00:35:10,530 --> 00:35:13,600
all over again by your own level
modeling left

509
00:35:13,600 --> 00:35:18,070
trees only really exist where our data
is tree shaped

510
00:35:18,070 --> 00:35:21,570
like my messages inside another my
messages

511
00:35:21,570 --> 00:35:25,359
X in elements inside others all the old

512
00:35:25,359 --> 00:35:28,410
traditional uses trees

513
00:35:28,410 --> 00:35:32,990
and this is the last thing I'll say
trees do besides representing tree shape

514
00:35:32,990 --> 00:35:33,550
data

515
00:35:33,550 --> 00:35:37,080
they are used very often to represent
sequential data

516
00:35:37,080 --> 00:35:40,440
that's constantly changing has stuff
coming in and out

517
00:35:40,440 --> 00:35:43,800
needs to be kept in order we have
outsourced

518
00:35:43,800 --> 00:35:47,680
trees to our data persistence layer to
our databases

519
00:35:47,680 --> 00:35:50,690
they all have trees inside and for
indexing

520
00:35:50,690 --> 00:35:54,460
the data systems have your own
long-running I keep a data structure

521
00:35:54,460 --> 00:35:56,400
around in RAM for weeks

522
00:35:56,400 --> 00:36:00,590
and meet the maintenance that it really
gives it but our programs today

523
00:36:00,590 --> 00:36:04,160
tend to be episodic concerned with a few
an update

524
00:36:04,160 --> 00:36:08,570
a report which turns us towards a
functional programming style

525
00:36:08,570 --> 00:36:12,859
that involves quick right wants
throwaway data structures that we create

526
00:36:12,859 --> 00:36:14,100
with comprehension

527
00:36:14,100 --> 00:36:18,050
we don't very often maintain a data
structure you don't very often

528
00:36:18,050 --> 00:36:22,830
keep a list around keep modifying it all
day long to keep in shape we need

529
00:36:22,830 --> 00:36:25,869
with outsource that to our storage layer
its

530
00:36:25,869 --> 00:36:30,840
some simple data-centric how'd
functional code is indeed the future

531
00:36:30,840 --> 00:36:34,220
as Uncle Bob Martin Gary Bernhardt
recently suggest

532
00:36:34,220 --> 00:36:39,100
see my eye 2013 talk between
architecture in Python

533
00:36:39,100 --> 00:36:43,300
then simple elegant lists and
dictionaries

534
00:36:43,300 --> 00:36:48,200
are exactly the data structures will be
taking us there

535
00:36:48,200 --> 00:36:55,200
thank you very much

536
00:36:59,390 --> 00:37:02,359
alas there's no time for questions of
even hallway

537
00:37:02,359 --> 00:37:09,359
please thank Brandon again right reagan
agenda 10 minutes we'll be back

538
00:37:12,240 --> 00:37:15,910
it's a half past for next talk see you
then

